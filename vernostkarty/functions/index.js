// index.js - KOMPLETNƒö OPRAVEN√Å VERZE S DETAILN√çM LOGOV√ÅN√çM

const functions = require("firebase-functions");
const { PKPass } = require("passkit-generator");
const admin = require("firebase-admin");
const fs = require("fs");
const axios = require("axios");
const cors = require("cors")({ origin: true });
const { Datastore } = require('@google-cloud/datastore');
const path = require("path");
const datastore = new Datastore();

// Inicializace Firebase Admin
admin.initializeApp({
  credential: admin.credential.cert(require("./certificates/vernostkarty-firebase-adminsdk-2j135-d46f086885.json")),
  storageBucket: "vernostkarty.appspot.com"
});

const db = admin.firestore();
const storageRef = admin.storage().bucket();

// Pomocn√° funkce: p≈ôevod HEX ‚Üí RGB
function hexToRgb(hex) {
  if (!hex) return null;
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result
    ? "rgb(" + parseInt(result[1], 16) + ", " + parseInt(result[2], 16) + ", " + parseInt(result[3], 16) + ")"
    : null;
}

// =========================
// Funkce createPass ‚Äì KOMPLETNƒö OPRAVEN√Å S DETAILN√çM LOGOV√ÅN√çM
// =========================
exports.createPass = functions.https.onRequest((req, res) => {
  cors(req, res, async () => {
    console.log("üöÄ createPass started");
    
    if (req.method !== 'POST') {
      console.log("‚ùå Invalid method:", req.method);
      return res.status(405).send('Method Not Allowed');
    }

    try {
      // 1) DETAILN√ç LOGOV√ÅN√ç P≈ò√çCHOZ√çHO PAYLOADU
      console.log("üì• Raw request body:", JSON.stringify(req.body, null, 2));
      
      const body = req.body;
      
      // Validace povinn√Ωch pol√≠ podle CAFEHTML.txt struktury
      const requiredFields = ['cardType', 'cafeId', 'userId'];
      for (const field of requiredFields) {
        if (!body[field]) {
          console.log(`‚ùå Missing required field: ${field}`);
          return res.status(400).json({
            result: "FAILED",
            explanation: `Missing required field: ${field}`
          });
        }
      }
      
      console.log("‚úÖ Required fields validation passed");
      console.log("üìã Card type:", body.cardType);
      console.log("üè™ Cafe ID:", body.cafeId);
      console.log("üë§ User ID:", body.userId);
      
      // 2) MAPOV√ÅN√ç POL√ç Z CAFEHTML.TXT STRUKTURY - ROZ≈†√ç≈òENO O V≈†ECHNY IDENTIFIK√ÅTORY
      const passData = {
        // Z√°kladn√≠ identifik√°tory - p≈ô√≠m√© mapov√°n√≠ z CAFEHTML.txt
        cardType: body.cardType,
        cafeId: body.cafeId,
        fullId: body.fullId,
        wixid: body.wixid,
        userId: body.userId,
        anonymousId: body.anonymousId,
        qrText: body.qrText,
        
        // Design
        cardColor: body.cardColor || '#ffffff',
        textColor: body.textColor || '#000000',
        logoURL: body.logoURL || '',
        stripImageURL: body.stripImageURL || '',
        thumbnailURL: body.thumbnailURL || '',
        
        // Pole pro pass
        primaryLabel: body.primaryLabel || 'VƒöRNOSTN√ç KARTA',
        primaryValue: body.primaryValue || '',
        discountLabel: body.discountLabel || '',
        discountValue: body.discountValue || '',
        headerCenterLabel: body.headerCenterLabel || '',
        headerCenterValue: body.headerCenterValue || '',
        
        // Auxiliary pole (z CAFEHTML.txt)
        auxiliary: body.auxiliary || []
      };
      
      console.log("üîÑ Mapped pass data:", JSON.stringify(passData, null, 2));
      console.log("üîç CRITICAL: RAW BODY z CAFEHTML.txt:", JSON.stringify(body, null, 2));
      console.log("üîç CRITICAL: V≈°echny identifik√°tory z body:");
      console.log("  - cafeId:", body.cafeId, "(typ:", typeof body.cafeId, ")");
      console.log("  - fullId:", body.fullId, "(typ:", typeof body.fullId, ")");
      console.log("  - wixid:", body.wixid, "(typ:", typeof body.wixid, ")");
      console.log("  - userId:", body.userId, "(typ:", typeof body.userId, ")");
      console.log("  - anonymousId:", body.anonymousId, "(typ:", typeof body.anonymousId, ")");
      console.log("üîç CRITICAL: V≈°echny identifik√°tory v passData:");
      console.log("  - cafeId:", passData.cafeId, "(typ:", typeof passData.cafeId, ")");
      console.log("  - fullId:", passData.fullId, "(typ:", typeof passData.fullId, ")");
      console.log("  - wixid:", passData.wixid, "(typ:", typeof passData.wixid, ")");
      console.log("  - userId:", passData.userId, "(typ:", typeof passData.userId, ")");
      console.log("  - anonymousId:", passData.anonymousId, "(typ:", typeof passData.anonymousId, ")");
      
      // 3) ULO≈ΩEN√ç DO DATASTORE
      console.log("üíæ Saving to Datastore...");
      const kind = 'cards';
      const cardKey = datastore.key(kind);
      
      const cardData = {
        ...passData,
        passStatus: "creating",
        passDownloadUrl: "",
        dateCreated: new Date().toISOString(),
        dateUpdated: new Date().toISOString()
      };
      console.log("üîç CRITICAL: cardData before save:", JSON.stringify(cardData, null, 2));
      
      await datastore.save({ key: cardKey, data: cardData });
      console.log("‚úÖ Saved to Datastore with ID:", cardKey.id);
      
      // 4) KONTROLA ≈†ABLONY PASS.JSON
      console.log("üìÑ Checking pass template...");
      const templatePath = "./myFirstModel.pass";
      if (!fs.existsSync(templatePath)) {
        throw new Error(`Pass template not found at: ${templatePath}`);
      }
      console.log("‚úÖ Pass template found");
      
      // 5) KONTROLA CERTIFIK√ÅT≈Æ - PODLE STAR√âHO FUNKƒåN√çHO K√ìDU
      console.log("üîê Checking certificates...");
      const certPaths = {
        wwdr: "./certificates/AppleWWDRCAG4.pem",
        signerCert: "./certificates/passCert.pem",
        signerKey: "./certificates/privatekey.key"
      };
      
      for (const [name, certPath] of Object.entries(certPaths)) {
        if (!fs.existsSync(certPath)) {
          throw new Error(`Certificate ${name} not found at: ${certPath}`);
        }
        console.log(`‚úÖ Certificate ${name} found`);
      }
      
      // 6) GENEROV√ÅN√ç PKPASS - PODLE STAR√âHO FUNKƒåN√çHO K√ìDU
      console.log("üé´ Generating PKPass...");
      
      const newPass = await PKPass.from({
          model: templatePath,
          certificates: {
            wwdr: fs.readFileSync(certPaths.wwdr),
            signerCert: fs.readFileSync(certPaths.signerCert),
            signerKey: fs.readFileSync(certPaths.signerKey),
            signerKeyPassphrase: "KEcTO078"
          }
        },
        {
          authenticationToken: "a7d8g9h2j4k5l6m7n8b9v0c1x2z3",
          webServiceURL: "https://applewalletwebhook-2sun3frzja-uc.a.run.app",
          serialNumber: String(cardKey.id),
          description: "Popis tv√©ho pasu",
          foregroundColor: hexToRgb(passData.textColor || "#000000"),
          labelColor: hexToRgb(passData.textColor || "#000000"),
          backgroundColor: hexToRgb(passData.cardColor || "#FFFFFF")
        }
      );
      
      console.log("‚úÖ PKPass object created successfully");
      
      // 7) P≈òID√ÅN√ç OBR√ÅZK≈Æ
      console.log("üñºÔ∏è Adding images...");
      
      // 6) P≈ôid√°n√≠ loga, stripu a thumbnailu, pokud URL existuj√≠ (PODLE STAR√âHO K√ìDU)
      if (passData.logoURL) {
        try {
          console.log("üì• Downloading logo from:", passData.logoURL);
          const respLogo = await axios.get(passData.logoURL, { responseType: 'arraybuffer' });
          const bufferLogo = Buffer.from(respLogo.data, "utf-8");
          newPass.addBuffer("logo.png", bufferLogo);
          newPass.addBuffer("logo@2x.png", bufferLogo);
          console.log("‚úÖ Logo added successfully");
        } catch (err) {
          console.log("‚ö†Ô∏è Logo download failed:", err.message);
        }
      }
      if (passData.stripImageURL) {
        try {
          console.log("üì• Downloading strip image from:", passData.stripImageURL);
          const respStrip = await axios.get(passData.stripImageURL, { responseType: 'arraybuffer' });
          const bufferStrip = Buffer.from(respStrip.data, "utf-8");
          newPass.addBuffer("strip.png", bufferStrip);
          newPass.addBuffer("strip@2x.png", bufferStrip);
          console.log("‚úÖ Strip image added successfully");
        } catch (err) {
          console.log("‚ö†Ô∏è Strip image download failed:", err.message);
        }
      }
      if (passData.thumbnailURL) {
        try {
          console.log("üì• Downloading thumbnail from:", passData.thumbnailURL);
          const respThumbnail = await axios.get(passData.thumbnailURL, { responseType: 'arraybuffer' });
          const bufferThumbnail = Buffer.from(respThumbnail.data, "utf-8");
          newPass.addBuffer("thumbnail.png", bufferThumbnail);
          newPass.addBuffer("thumbnail@2x.png", bufferThumbnail);
          console.log("‚úÖ Thumbnail added successfully");
        } catch (err) {
          console.log("‚ö†Ô∏è Thumbnail download failed:", err.message);
        }
      }
      
      // 8) P≈òID√ÅN√ç POL√ç - P≈òESN√Å KOPIE STAR√âHO FUNKƒåN√çHO INDEX.JS
      console.log("üìù Adding pass fields using EXACT old logic...");
      
      // 7) P≈ôid√°n√≠ primary, header, secondary a auxiliary pol√≠ (PODLE STAR√âHO K√ìDU)
      // POZN√ÅMKA: primaryFields se zobrazuj√≠ P≈òES STRIP - pokud nechceme text p≈ôes strip, mus√≠me je vynechat
      // newPass.primaryFields.push({
      //   key: "primary",
      //   label: passData.primaryLabel || "",
      //   value: passData.primaryValue || ""
      // });
      console.log("‚úÖ Skipping primaryField to avoid text over strip");
      
      // Vlevo (prvn√≠ pole) ‚Äì m≈Ø≈æe b√Ωt ponech√°no pr√°zdn√© nebo doplnƒõno podle pot≈ôeby
      // St≈ôed (druh√© pole)
      if (passData.headerCenterLabel || passData.headerCenterValue) {
        newPass.headerFields.push({
          key: "center",
          label: passData.headerCenterLabel || "",
          value: passData.headerCenterValue || ""
        });
        console.log(`‚úÖ Added headerField (center): ${passData.headerCenterValue}`);
      }
      // Vpravo (t≈ôet√≠ pole)
      newPass.headerFields.push({
        key: "discountLevel",
        label: passData.discountLabel || "",
        value: passData.discountValue || ""
      });
      console.log(`‚úÖ Added headerField (discount): ${passData.discountValue}`);
      
      // Secondary fields (pokud jsou v datech)
      if (Array.isArray(passData.secondary)) {
        passData.secondary.forEach((sec, idx) => {
          newPass.secondaryFields.push({
            key: "secondary" + idx,
            label: sec.label || "",
            value: sec.value || ""
          });
          console.log(`‚úÖ Added secondaryField ${idx}`);
        });
      }
      
      // Auxiliary fields (pole pod pruhem)
      if (Array.isArray(passData.auxiliary)) {
        console.log("Processing auxiliary fields:", JSON.stringify(passData.auxiliary));
        passData.auxiliary.forEach((aux, idx) => {
          newPass.auxiliaryFields.push({
            key: "auxiliary" + idx,
            label: aux.label || "",
            value: aux.value || ""
          });
          console.log(`‚úÖ Added auxiliaryField ${idx}: ${aux.label} = ${aux.value}`);
        });
      }
      
      console.log("‚úÖ All fields added using old logic.");
      
      // 9) QR K√ìD
      if (passData.qrText) {
        console.log("üî≤ Adding QR code:", passData.qrText);
        newPass.setBarcodes({
          message: passData.qrText,
          format: "PKBarcodeFormatQR",
          messageEncoding: "iso-8859-1"
        });
        console.log("‚úÖ QR code added successfully");
      }
      
      // 10) KRITICK√Å OPRAVA: Odstranƒõn√≠ headerFields pro storeCard (Apple je zakazuje)
      console.log("üîß Removing forbidden headerFields for storeCard...");
      if (newPass.props && newPass.props.storeCard && newPass.props.storeCard.headerFields) {
        delete newPass.props.storeCard.headerFields;
        console.log("‚úÖ headerFields removed from storeCard");
      }
      
      // 11) GENEROV√ÅN√ç FIN√ÅLN√çHO BUFFERU
      console.log("üîÑ Generating final pass buffer...");
      const bufferData = await newPass.getAsBuffer();
      console.log("üìè Final pass buffer size:", bufferData.length, "bytes");
      
      if (bufferData.length === 0) {
        throw new Error("Generated pass buffer is empty");
      }
      
      // 12) ULO≈ΩEN√ç DO FIREBASE STORAGE
      console.log("‚òÅÔ∏è Uploading to Firebase Storage...");
      const fileName = `passes/${String(cardKey.id)}.pkpass`;
      const passFileRef = storageRef.file(fileName);
      
      await passFileRef.save(bufferData, {
        metadata: {
          contentType: 'application/vnd.apple.pkpass'
        }
      });
      console.log("‚úÖ Uploaded to Firebase Storage:", fileName);
      
      // 13) Z√çSK√ÅN√ç SIGNED URL
      console.log("üîó Generating signed URL...");
      const [signedUrl] = await passFileRef.getSignedUrl({
        action: 'read',
        expires: '03-01-2030'
      });
      console.log("‚úÖ Signed URL generated:", signedUrl);
      
      // 13) AKTUALIZACE DATASTORE - MERGE UPDATE (zachov√° p≈Øvodn√≠ identifik√°tory)
      console.log("üíæ Updating Datastore with download URL (merge mode)...");
      
      // Nejprve naƒçteme p≈Øvodn√≠ data
      const [existingCard] = await datastore.get(cardKey);
      if (!existingCard) {
        throw new Error("Card not found in Datastore for update");
      }
      
      // Merge - zachov√°me p≈Øvodn√≠ data a p≈ôid√°me nov√° pole
      const updatedData = {
        ...existingCard,  // Zachov√° v≈°echny p≈Øvodn√≠ identifik√°tory
        passDownloadUrl: signedUrl, 
        passStatus: 'uploaded', 
        dateUpdated: new Date().toISOString() 
      };
      
      await datastore.save({
        key: cardKey,
        data: updatedData
      });
      console.log("‚úÖ Datastore updated successfully (identifiers preserved)");
      
      // 14) √öSPƒö≈†N√Å ODPOVƒöƒé
      const response = {
        status: "Pass was successfully generated",
        result: "SUCCESS",
        cardId: String(cardKey.id),
        downloadUrl: signedUrl
      };
      
      console.log("üéâ SUCCESS! Response:", JSON.stringify(response, null, 2));
      res.status(200).json(response);
      
    } catch (error) {
      console.error("üí• CRITICAL ERROR in createPass:", error);
      console.error("üìö Error stack:", error.stack);
      
      const errorResponse = {
        result: "FAILED",
        explanation: error.message,
        timestamp: new Date().toISOString()
      };
      
      console.log("‚ùå Error response:", JSON.stringify(errorResponse, null, 2));
      res.status(500).json(errorResponse);
    }
  });
});

// =========================
// Nov√° funkce createCard
// =========================
const createCardModule = require("./createCard");

// =========================
// Apple Wallet Webhook
// =========================
const appleWalletWebhookModule = require("./appleWalletWebhook");

// =========================
// Test Pass Function
// =========================
const testPassModule = require("./testPass");

exports.createCard = functions.https.onRequest(createCardModule.createCard);
exports.appleWalletWebhook = appleWalletWebhookModule.appleWalletWebhook;
exports.testPass = testPassModule.testPass;

// =========================
// HTTP endpoint pro aktualizaci dateUpdated v kart√°ch
// =========================
exports.updateCardsTimestamp = functions.https.onRequest(async (req, res) => {
  console.log('üîÑ updateCardsTimestamp endpoint called');
  
  // CORS headers
  res.set('Access-Control-Allow-Origin', '*');
  res.set('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.set('Access-Control-Allow-Headers', 'Content-Type');
  
  if (req.method === 'OPTIONS') {
    return res.status(200).send();
  }
  
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }
  
  try {
    const { deviceLibraryIdentifier } = req.body;
    
    if (!deviceLibraryIdentifier) {
      return res.status(400).json({ error: 'deviceLibraryIdentifier is required' });
    }
    
    console.log(`üîç Hled√°m karty pro deviceLibraryIdentifier: ${deviceLibraryIdentifier}`);
    
    // Naj√≠t v≈°echny z√°znamy pro toto za≈ô√≠zen√≠
    const query = datastore.createQuery('userdeviceinfo')
      .filter('deviceLibraryIdentifier', '=', deviceLibraryIdentifier);
    
    const [deviceInfos] = await datastore.runQuery(query);
    console.log(`üìã Nalezeno ${deviceInfos.length} z√°znam≈Ø pro toto za≈ô√≠zen√≠`);
    
    if (deviceInfos.length === 0) {
      return res.status(404).json({ error: 'No cards found for this device' });
    }
    
    // Aktualizovat dateUpdated pro v≈°echny karty tohoto za≈ô√≠zen√≠
    const updatePromises = [];
    const currentTime = new Date().toISOString();
    let updatedCount = 0;
    
    for (const info of deviceInfos) {
      const serialNumber = info.serialNumber;
      if (serialNumber) {
        const cardKey = datastore.key(['cards', datastore.int(serialNumber)]);
        
        // Naƒçteme kartu a aktualizujeme dateUpdated
        const updatePromise = datastore.get(cardKey).then(([card]) => {
          if (card) {
            const updatedCard = {
              ...card,
              dateUpdated: currentTime
            };
            updatedCount++;
            console.log(`‚úÖ Aktualizuji dateUpdated pro kartu ${serialNumber}`);
            return datastore.save({ key: cardKey, data: updatedCard });
          }
        });
        
        updatePromises.push(updatePromise);
      }
    }
    
    await Promise.all(updatePromises);
    
    const response = {
      success: true,
      message: `Updated ${updatedCount} cards`,
      timestamp: currentTime,
      deviceLibraryIdentifier: deviceLibraryIdentifier
    };
    
    console.log(`üéâ √öspƒõ≈°nƒõ aktualizov√°no ${updatedCount} karet`);
    res.status(200).json(response);
    
  } catch (error) {
    console.error('‚ùå Chyba p≈ôi aktualizaci karet:', error);
    res.status(500).json({ 
      error: 'Internal server error', 
      message: error.message 
    });
  }
});

// Nov√° funkce pro generov√°n√≠ aktualizovan√Ωch pass≈Ø s daty z Firestore
exports.generateUpdatedPass = functions.https.onRequest(async (req, res) => {
  try {
    console.log('üîÑ generateUpdatedPass endpoint called');
    console.log('Request body:', JSON.stringify(req.body, null, 2));
    
    const { serialNumber, wixid, email } = req.body;
    
    if (!serialNumber || !wixid || !email) {
      return res.status(400).json({ 
        error: 'Missing required parameters: serialNumber, wixid, email' 
      });
    }
    
    // 1. Inicializace sekund√°rn√≠ aplikace pro vernostkarty-db
    const serviceAccountDb = require('./certificates/vernostkarty-db-service-account.json');
    let dbApp;
    try {
      dbApp = admin.app('dbAdmin');
    } catch (e) {
      dbApp = admin.initializeApp({
        credential: admin.credential.cert(serviceAccountDb)
      }, 'dbAdmin');
    }
    const firestoreDb = dbApp.firestore();
    
    // 2. Naƒçten√≠ aktu√°ln√≠ch dat z Firestore (vernostkarty-db)
    console.log(`üìã Loading current data from Firestore: users/${wixid}/emails/${email}`);
    const userDocRef = firestoreDb.collection('users').doc(wixid).collection('emails').doc(email);
    const userDoc = await userDocRef.get();
    
    if (!userDoc.exists) {
      console.error(`‚ùå User document not found: users/${wixid}/emails/${email}`);
      return res.status(404).json({ error: 'User data not found' });
    }
    
    const userData = userDoc.data();
    console.log('üìã Current user data from Firestore:', JSON.stringify(userData, null, 2));
    
    // 3. Naƒçten√≠ p≈Øvodn√≠ karty z Datastore pro z√°kladn√≠ metadata
    const cardKey = datastore.key(['cards', datastore.int(serialNumber)]);
    const [originalCard] = await datastore.get(cardKey);
    
    if (!originalCard) {
      console.error(`‚ùå Original card not found in Datastore: ${serialNumber}`);
      return res.status(404).json({ error: 'Original card not found' });
    }
    
    console.log('üìã Original card metadata:', JSON.stringify(originalCard, null, 2));
    
    // 4. Aplikace logiky mapov√°n√≠ pol√≠ podle cardType (stejnƒõ jako CAFEHTML)
    const cardType = userData.cardType || originalCard.cardType || 'card-body';
    console.log(`üîç Processing card type: ${cardType}`);
    
    // Vytvo≈ôen√≠ payload podle logiky CAFEHTML
    const payload = {
      primaryLabel: "VƒöRNOSTN√ç KARTA",
      primaryValue: originalCard.businessName || '',
      discountLabel: '',
      discountValue: '',
      headerCenterLabel: '',
      headerCenterValue: '',
      auxiliary: [
        { label: userData.name || '', value: userData.surname || '' }, // Jm√©no u≈æivatele
        { label: '', value: '' } // Bude nastaveno podle cardType
      ]
    };
    
    // Mapov√°n√≠ pol√≠ podle cardType (logika z CAFEHTML)
    switch (cardType) {
      case 'card-body':
        payload.discountLabel = userData.bodyLabel1Input || 'BODY';
        payload.discountValue = userData.bodyValInput || '0';
        payload.auxiliary[1] = {
          label: userData.bodyBottomTopInput || '',
          value: userData.bodyBottomBotInput || ''
        };
        break;
        
      case 'card-razitka':
        payload.auxiliary[1] = {
          label: 'RAZ√çTKA',
          value: `${userData.stampValInput || '0'} / ${userData.stampCount || '0'}`
        };
        break;
        
      case 'card-procentni':
        payload.discountLabel = 'SLEVA';
        payload.discountValue = `${userData.level1_sleva || '0'} %`;
        payload.headerCenterLabel = 'STATUS';
        payload.headerCenterValue = userData.level1_status || 'VIP';
        payload.auxiliary[1] = {
          label: 'U≈†ET≈òENO',
          value: '' // Pr√°zdn√° hodnota podle CAFEHTML
        };
        break;
        
      default:
        console.warn(`‚ö†Ô∏è Unknown cardType: ${cardType}, using default mapping`);
        break;
    }
    
    console.log('üìã Generated payload:', JSON.stringify(payload, null, 2));
    
    // 5. Generov√°n√≠ PKPass s aktu√°ln√≠mi daty (logika z createPass)
    console.log("üé´ Generating PKPass with current data...");
    
    const newPass = await PKPass.from(
      {
        model: "./myFirstModel.pass",
        certificates: {
          wwdr: fs.readFileSync("./certificates/wwdr.pem"),
          signerCert: fs.readFileSync("./certificates/signerCert.pem"),
          signerKey: fs.readFileSync("./certificates/signerKey.pem"),
          signerKeyPassphrase: "test"
        }
      },
      {
        authenticationToken: "a7d8g9h2j4k5l6m7n8b9v0c1x2z3",
        webServiceURL: "https://applewalletwebhook-2sun3frzja-uc.a.run.app",
        serialNumber: String(serialNumber),
        description: "Aktualizovan√° vƒõrnostn√≠ karta",
        foregroundColor: originalCard.design?.contentColor || "#000000",
        backgroundColor: originalCard.design?.backgroundColor || "#ffffff",
        labelColor: originalCard.design?.headerColor || "#000000"
      }
    );
    
    // 6. P≈ôid√°n√≠ pol√≠ podle cardType (logika z createPass)
    console.log("üìù Adding fields based on cardType...");
    
    // Primary field
    if (payload.primaryLabel && payload.primaryValue) {
      newPass.storeCard().primaryFields.add('primary', payload.primaryLabel, payload.primaryValue);
    }
    
    // Secondary fields (discount a header center)
    if (payload.discountLabel && payload.discountValue) {
      newPass.storeCard().secondaryFields.add('discount', payload.discountLabel, payload.discountValue);
    }
    
    if (payload.headerCenterLabel && payload.headerCenterValue) {
      newPass.storeCard().secondaryFields.add('headerCenter', payload.headerCenterLabel, payload.headerCenterValue);
    }
    
    // Auxiliary fields
    payload.auxiliary.forEach((aux, index) => {
      if (aux.label || aux.value) {
        newPass.storeCard().auxiliaryFields.add(`aux${index}`, aux.label, aux.value);
      }
    });
    
    // QR k√≥d
    const qrText = originalCard.qrText || `https://onlineloyaltycards.com/editor/?id=${wixid}/${userData.anonymousId || email}`;
    newPass.barcode(qrText, 'PKBarcodeFormatQR');
    
    // 7. Generov√°n√≠ fin√°ln√≠ho .pkpass souboru
    console.log("üîÑ Generating final .pkpass file...");
    const passBuffer = await newPass.generate();
    
    console.log(`‚úÖ Generated updated pass for ${serialNumber} with ${passBuffer.length} bytes`);
    
    // 8. Odesl√°n√≠ odpovƒõdi
    res.set('Content-Type', 'application/vnd.apple.pkpass');
    res.set('Last-Modified', new Date().toUTCString());
    return res.status(200).send(passBuffer);
    
  } catch (error) {
    console.error('‚ùå Error generating updated pass:', error);
    res.status(500).json({ 
      error: 'Failed to generate updated pass', 
      message: error.message 
    });
  }
});